# FullArray

![image-20220310112009900](https://cdn.jsdelivr.net/gh/lotushint/Image/Image/202203101120651.png)

------

# Sort

## 归并排序：

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。

    归并排序 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

算法描述
步骤1：把长度为n的输入序列分成两个长度为n/2的子序列；
步骤2：对这两个子序列分别采用归并排序；
步骤3：将两个排序好的子序列合并成一个最终的排序序列。

# LongestContinuousAscendingSubsequence

## 最长连续上升子序列

### 动态规划算法的基本要素

#### 1.最优子结构

1.最优子结构性质:问题的最优解包含着其子问题的最优解。
2.在分析问题的最优子结构性质时，所用的方法具有普遍性：首先假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾。
3.利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。最优子结构是问题能用动态规划算法求解的前提。

#### 2.重叠子问题

1.递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为子问题的重叠性质。
2.动态规划算法，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。
3.通常不同的子问题个数随问题的大小呈多项式增长。因此用动态规划算法只需要多项式时间，从而获得较高的解题效率。

<img src="https://cdn.jsdelivr.net/gh/lotushint/Image/Image/202204031549695.png" alt="image-20220403154925172" style="zoom:50%;" />

# MaxMatrixSum

![image-20220414132331684](https://cdn.jsdelivr.net/gh/lotushint/Image/Image/202204141323210.png)

```java
解题思路：最大子矩阵一定在某两行之间，假设最大矩阵位于第i行到第j行之间，这时我们只需要判断最大子矩阵在哪两列之间就行了，枚举复杂度太高，所以我们可以将二维的矩阵压缩成一维，用数组c[]保存每一列第i行到第j行之间的和 ，然后求数组c的最大连续子段和，就可以了

1、用b[i]来记录某一行到第i行的某一列的和。
2、用b[k]=b[k]+a[j][k]来更新。
3、用sum=sum+b[k] 来记录第i行到下面的那一行的那个矩阵的和(列数变化)。
4、if(sum<b[k])表示第k列之前的矩阵为负，最大和就为sum=b[k];
5、更新max。
```

# MatrixMultiplication

![image-20220420092215577](https://cdn.jsdelivr.net/gh/lotushint/Image/Image/202204200926299.png)

```python
30 35 15 5 10 20 25
#第一次：从最初开始划分，划分两个子矩阵，首先列出所有情况。
	A1A2 30*35*15=15750
	A2A3 35*15*5=2625      
	A3A4 15*5*10=750    
	A4A5 5*10*20=1000
	A5A6 10*20*25=5000
    
#第二次：划分三个子矩阵
	A1A2A3：	(A1(A2A3))2625+30*35*5 = 7875或((A1A2)A3)15750+30*15*5=18000，显然选择7875
	A2A3A4：			  2625+35*5*10 = 4375或          750+35*15*10 = 6000，显然选择4375
	A3A4A5：			  750+15*10*20 = 3750或		    1000+15*5*20 = 2500，显然选择2500
	A4A5A6：			  1000+5*20*25 = 3500或		    5000+5*10*25 = 6250，显然选择3500

#第三次：划分四个子矩阵
A1A2A3A4：(A1A2A3)A4： 7875+30* 5*10= 9375或A1(A2A3A4)： 2500+35*10*30 = 13000或(A1A2)(A3A4)： 15750+750+30*15*10 = 21000显然选择9375
A2A3A4A5：(A2A3A4)A5： 4375+35*10*20=11375或A2(A3A4A5)： 2500+15*20*35 = 13000或(A2A3)(A4A5)： 2625+1000+35* 5*20 = 7125显然选择7125
A3A4A5A6：(A3A4A5)A6： 2500+15*20*25=10000或A3(A4A5A6)： 3500+ 5*25*15 =  5375或(A3A4)(A5A6)：  750+5000+15*10*25 = 9500显然选择5375

#第四次：划分五个子矩阵
A1A2A3A4A5： 11875
A2A3A4A5A6： 10500

#第五次：最后对整个矩阵链进行划分。

A1(A2A3A4A5A6)  ：30*35*25+18500      =44750
(A1A2)(A3A4A5A6)：157580+5375+30*5*25 =32375
(A1A2A3)(A4A5A6)：7875+3500+30*5*25   =15125
(A1A2A3A4)(A5A6)：9375+5000+30*10*25	 =21875
(A1A2A3A4A5)A6  ：15375+30*20*25		 =30375

```

<img src="https://cdn.jsdelivr.net/gh/lotushint/Image/Image/202204201000158.png" alt="image-20220420100044014" style="zoom:150%;" />

